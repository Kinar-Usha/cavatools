#!/usr/bin/env python

from builtins import hex
from builtins import range
import math
import sys
import re
import os
import json
from collections import OrderedDict

def eprint(*args):
    sys.stderr.write(' '.join(map(str,args)) + '\n')
    
def diffcp(fname):
    if os.path.exists(fname) and os.system('cmp -s newcode.tmp '+fname) == 0:
        os.system('rm newcode.tmp')
    else:
        #eprint(fname, 'updated')
        os.system('mv newcode.tmp '+fname)

opcodes = OrderedDict()
for filename in sys.argv[1:]:
    with open(filename) as f:
        d = json.load(f)
    for name, attrs in d.items():
        if name in opcodes:
            for a in attrs:
                opcodes[name][a] = attrs[a]
        else:
            opcodes[name] = attrs

regs = {}
regs['cfd']	= ( 2, 3, '+8+FPREG', 'op_rd')
regs['crd']	= ( 2, 3, '+8+GPREG', 'op_rd')
regs['cs2']	= ( 2, 3, '+8+GPREG', 'op.rs2')
regs['ds2']	= ( 2, 3, '+8+FPREG', 'op.rs2')
regs['fs4']	= ( 2, 5, '+FPREG',   'op.rs2')
regs['rs4']	= ( 2, 5, '+GPREG',   'op.rs2')
regs['cs1']	= ( 7, 3, '+8+GPREG', 'op_rs1')
regs['cd1']	= ( 7, 3, '+8+GPREG', 'op_rd',  'op_rs1')
regs['rd1']	= ( 7, 5, '+GPREG',   'op_rd',  'op_rs1')
regs['rs5']	= ( 7, 5, '+GPREG',   'op_rs1')

regs['rd']	= ( 7, 5, '+GPREG',   'op_rd')
regs['fd']	= ( 7, 5, '+FPREG',   'op_rd')
regs['vd']	= ( 7, 5, '+VPREG',   'op_rd')
regs['vs3']	= ( 7, 5, '+VPREG',   'op.rs3')

regs['rs1']	= (15, 5, '+GPREG',   'op_rs1')
regs['fs1']	= (15, 5, '+FPREG',   'op_rs1')
regs['vs1']	= (15, 5, '+VPREG',   'op_rs1')

regs['rs2']	= (20, 5, '+GPREG',   'op.rs2')
regs['fs2']	= (20, 5, '+FPREG',   'op.rs2')
regs['vs2']	= (20, 5, '+VPREG',   'op.rs2')

regs['rs3']	= (27, 5, '+GPREG',   'op.rs3')
regs['fs3']	= (27, 5, '+FPREG',   'op.rs3')

regs['vm']	= (25, 1, '+VMREG',   'op_vm')

errors = 0
for name in opcodes:
    if 'bits' not in opcodes[name]:
        print(name, opcodes[name]);
        continue;
    for b in opcodes[name]['bits'].split():
        if re.match('[01]+|\{[^}]+\}', b):
            continue
        if b not in regs:
            eprint('Undefined register', b)
            errors += 1
if errors:  exit(-1)

with open('newcode.tmp', 'w') as f:
    f.write('enum Opcode_t {')
    n = 0
    opcode_list = ['ZERO']
    for name in opcodes.keys():
        if 'fast' in opcodes[name]['flags']:
            opcode_list.append(name)
    for name in opcodes.keys():
        if 'fast' not in opcodes[name]['flags']:
            opcode_list.append(name)
    # Special opcodes
    opcode_list.append('cas.w')
    opcode_list.append('cas.d')
    opcode_list.append('c_cas.w')
    opcode_list.append('c_cas.d')
    opcode_list.append('ILLEGAL')
    opcode_list.append('UNKNOWN')
    for name in opcode_list:
        if n % 8 == 0:
            f.write('\n  ')
        f.write('{:24s}'.format('Op_' + name.replace('.','_') + ','))
        n += 1
    f.write('};\n')
diffcp('opcodes.h')

with open('newcode.tmp', 'w') as f:
    for name in opcodes:
        pos = 0
        code = 0
        mask = 0
        immed = []
        bigimm = 0
        registers = []
        type = opcodes[name]['type']
        if type=='crs' or type=='cds' or type=='csl' or type=='css':
            registers.append('i.op_rs1=2')
        if type=='cjl':
            registers.append('i.op_rd=1')
        if type=='cds':
            registers.append('i.op_rd=2')
        for b in reversed(opcodes[name]['bits'].split()):
            if re.match('[01]+', b):
                code |= int(b, 2) << pos
                mask |= ((1<<len(b))-1) << pos
                pos += len(b)
            elif re.match('\{[^}]+\}', b):
                tuple = []
                signed = False
                i = 0
                if b[1] == '-':
                    signed = True
                    i = 1
                while b[i] != '}':
                    i += 1
                    m = re.match('(\d+)(:\d+)?', b[i:])
                    if not m:
                        eprint('Bad immediate', name, b[i:])
                        exit(-1)
                    hi = int(m.group(1))
                    lo = hi
                    if m.group(2):
                        lo = int(m.group(2)[1:])
                    tuple.append((hi, lo))
                    i += len(m.group(0))
                    if hi >= 16:  bigimm = 1
                for (hi, lo) in reversed(tuple[1:]):
                    shift = lo and '<<{:d}'.format(lo) or ''
                    immed.append('x({:d},{:d}){:s}'.format(pos, hi-lo+1, shift))
                    pos += hi-lo+1
                (hi, lo) = tuple[0]
                shift = lo and '<<{:d}'.format(lo) or ''
                immed.append('{:s}({:d},{:d}){:s}'.format(signed and 'xs' or 'x', pos, hi-lo+1, shift))
                pos += hi-lo+1
            else:
                lo = regs[b][0]
                width = regs[b][1]
                offset = regs[b][2]
                for reg in regs[b][3:]:
                    registers.append('i.{:s}=x({:d},{:d}){:s}'.format(reg, lo, width, offset))
                pos += width
        if pos == 16:
            opcodes[name]['len'] = 2
            biginsn = 0
            f.write('  if((b&0x{:04x})==0x{:04x})'.format(mask, code))
        elif pos == 32:
            opcodes[name]['len'] = 4
            biginsn = 1
            f.write('  if((b&0x{:08x})==0x{:08x})'.format(mask, code))
        else:
            eprint('Illegal length', name, pos, 'bits', opcodes[name]['bits'])
            eprint(immed)
            exit(-1)
        f.write(' {{ i=Insn_t(Op_{:s},{:d},{:d});\t'.format(name.replace('.','_'), biginsn, bigimm))
        f.write('; '.join(registers))
        if immed:
            f.write(';\ti.{:s}={:s}'.format(bigimm and 'op_immed' or 'op.imm', '|'.join(immed)))
        f.write('; goto opcode_found; }\n')
diffcp('decoder.h')

with open('newcode.tmp', 'w') as f:
    for name in opcodes:
        f.write('long I_{:s}(long pc, cpu_t* cpu);\n'.format(name.replace('.','_')))
    f.write('\n')
    f.write('long (*golden[])(long pc, cpu_t* cpu) = {')
    i = 0
    #for name in ['ZERO'] + list(opcodes.keys()) + ['ILLEGAL', 'UNKNOWN']:
    for name in opcode_list:
        if i % 4 == 0:
            f.write('\n  ')
        if name in opcodes:
            f.write('&I_{:21s}'.format(name.replace('.','_')+','))
        else:
            f.write('{:24s}'.format('0,'))
        i += 1
    f.write('\n};\n')
diffcp('dispatch_table.h')

with open('newcode.tmp', 'w') as f:
    f.write('const char* op_name[] = {')
    i = 0
    #for name in ['ILLEGAL'] + list(opcodes.keys()) + ['ILLEGAL', 'UNKNOWN']:
    for name in opcode_list:
        if i % 4 == 0:
            f.write('\n  ')
        name2 = name.replace('.','_')
        f.write('{:24s}'.format('"'+name2+'",'))
        i += 1
    f.write('\n};\n')
diffcp('constants.h')

if not os.path.exists('./insns'):
    os.mkdir('./insns')

errors = 0
for name in opcodes:
    with open('newcode.tmp', 'w') as f:
        opcode = opcodes[name]
        f.write('#include "interpreter.h"\n')
        f.write('long I_{:s}(long pc, cpu_t* cpu) {{\n'.format(name.replace('.','_')))
        f.write('  processor_t* p = cpu->spike();\n');
        f.write('  insn_t insn = (long)(*(int{:d}_t*)pc);\n'.format(opcode['len']*8))
        if 'flags' in opcode:
            if 'pc' in opcode['flags']:
                f.write('  long npc = pc + {:d};\n'.format(opcode['len']))
            for line in opcode["exec"].split('\n'):
                if line:
                    f.write('  {:s}\n'.format(line))
            if 'pc' in opcode['flags']:
                f.write('  return npc;\n')
            else:
                f.write('  return pc + {:d};\n'.format(opcode['len']))
        else:
            f.write('  return pc + {:d};\n'.format(opcode['len']))
        f.write('}\n')
    diffcp('./insns/{:s}.cc'.format(name.replace('.','_')))

with open('newcode.tmp', 'w') as f:
    for name in opcodes:
        opcode = opcodes[name]
        if 'fast' not in opcode:
            continue;
        f.write('case Op_{:s}:  {:s}; pc+={:d}; break;\n'.format(name.replace('.','_'), opcode['fast'], opcode['len']))
diffcp('fastops.h')
